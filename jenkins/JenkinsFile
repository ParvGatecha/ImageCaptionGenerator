
pipeline {
    agent any

    environment {
        // --- Configuration ---
        DOCKER_REGISTRY = 'docker.io/parvg' // Your Docker Hub username
        DOCKER_CREDENTIALS_ID = 'docker-hub-credentials' // Jenkins Credentials ID for Docker registry
        KUBECONFIG_CREDENTIALS_ID = 'kube-config' // Jenkins Credentials ID for Kubeconfig
        K8S_NAMESPACE = 'spe-project'
        
        // Image names
        FRONTEND_IMAGE_NAME = "${DOCKER_REGISTRY}/spefrontend"
        CAPTION_IMAGE_NAME = "${DOCKER_REGISTRY}/caption"
        OBJECT_IMAGE_NAME = "${DOCKER_REGISTRY}/object"
        
        // Use build number for image tags
        IMAGE_TAG = "build-${BUILD_NUMBER}"
        
        // Email configuration
        EMAIL_RECIPIENTS = 'googloid111@gmail.com' // Replace with actual email
    }

    options {
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timestamps()
        timeout(time: 1, unit: 'HOURS')
        disableConcurrentBuilds()
    }

    stages {
        stage('Checkout') {
            steps {
                echo "Checking out source code..."
                checkout scm
            }
        }

        stage('Build Frontend Image') {
            steps {
                script {
                    echo "Building frontend Docker image: ${FRONTEND_IMAGE_NAME}:${IMAGE_TAG}"
                    dir('frontend') {
                        def frontendImage = docker.build("${FRONTEND_IMAGE_NAME}:${IMAGE_TAG}", "--pull -f Dockerfile .")
                    }
                }
            }
        }

        stage('Build Caption Image') {
            steps {
                script {
                    echo "Building caption Docker image: ${CAPTION_IMAGE_NAME}:${IMAGE_TAG}"
                    dir('caption') {
                        def captionImage = docker.build("${CAPTION_IMAGE_NAME}:${IMAGE_TAG}", "--pull -f Dockerfile .")
                    }
                }
            }
        }

        stage('Build Object Detection Image') {
            steps {
                script {
                    echo "Building object detection Docker image: ${OBJECT_IMAGE_NAME}:${IMAGE_TAG}"
                    dir('object') {
                        def objectImage = docker.build("${OBJECT_IMAGE_NAME}:${IMAGE_TAG}", "--pull -f Dockerfile .")
                    }
                }
            }
        }

        stage('Push Images') {
            steps {
                script {
                    echo "Pushing images to registry: ${DOCKER_REGISTRY}"
                    docker.withRegistry("https://${DOCKER_REGISTRY}", DOCKER_CREDENTIALS_ID) {
                        // Push frontend image
                        echo "Pushing ${FRONTEND_IMAGE_NAME}:${IMAGE_TAG}"
                        docker.image("${FRONTEND_IMAGE_NAME}:${IMAGE_TAG}").push()
                        docker.image("${FRONTEND_IMAGE_NAME}:${IMAGE_TAG}").push('latest')

                        // Push caption image
                        echo "Pushing ${CAPTION_IMAGE_NAME}:${IMAGE_TAG}"
                        docker.image("${CAPTION_IMAGE_NAME}:${IMAGE_TAG}").push()
                        docker.image("${CAPTION_IMAGE_NAME}:${IMAGE_TAG}").push('latest')

                        // Push object detection image
                        echo "Pushing ${OBJECT_IMAGE_NAME}:${IMAGE_TAG}"
                        docker.image("${OBJECT_IMAGE_NAME}:${IMAGE_TAG}").push()
                        docker.image("${OBJECT_IMAGE_NAME}:${IMAGE_TAG}").push('latest')
                    }
                }
            }
        }

        stage('Deploy to Kubernetes') {
            steps {
                script {
                    echo "Deploying to Kubernetes namespace: ${K8S_NAMESPACE}"
                    withKubeConfig([credentialsId: KUBECONFIG_CREDENTIALS_ID]) {
                        // 1. Create namespace if it doesn't exist
                        sh "kubectl apply -f kubernetes/namespace.yaml"

                        // 2. Apply shared model PVC
                        sh "kubectl apply -f kubernetes/shared-model.yaml"

                        // 3. Apply services
                        sh "kubectl apply -f kubernetes/frontend-service.yaml"
                        sh "kubectl apply -f kubernetes/backend-service.yaml"
                        sh "kubectl apply -f kubernetes/object-detector-service.yaml"

                        // 4. Apply ingress
                        sh "kubectl apply -f kubernetes/ingress.yaml"

                        // 5. Apply monitoring
                        sh "kubectl apply -f kubernetes/app-servicemonitors.yaml"
                        sh "kubectl apply -f kubernetes/grafana-ingress.yaml"
                        sh "kubectl apply -f kubernetes/grafana-values.yaml"

                        // 6. Update deployments with new images
                        sh """
                            kubectl set image deployment/frontend-deployment frontend=${FRONTEND_IMAGE_NAME}:${IMAGE_TAG} -n ${K8S_NAMESPACE} --record
                            kubectl set image deployment/backend-deployment backend=${CAPTION_IMAGE_NAME}:${IMAGE_TAG} -n ${K8S_NAMESPACE} --record
                            kubectl set image deployment/object-detector-deployment object-detector=${OBJECT_IMAGE_NAME}:${IMAGE_TAG} -n ${K8S_NAMESPACE} --record
                        """

                        // 7. Wait for rollouts to complete
                        sh """
                            kubectl rollout status deployment/frontend-deployment -n ${K8S_NAMESPACE} --timeout=5m
                            kubectl rollout status deployment/backend-deployment -n ${K8S_NAMESPACE} --timeout=5m
                            kubectl rollout status deployment/object-detector-deployment -n ${K8S_NAMESPACE} --timeout=5m
                        """
                    }
                }
            }
        }
    }

    post {
        always {
            echo 'Pipeline finished.'
            cleanWs()
        }
        success {
            echo 'Pipeline succeeded!'
            emailext (
                subject: "Pipeline Successful: ${env.JOB_NAME} [${env.BUILD_NUMBER}]",
                body: """
                    Pipeline ${env.JOB_NAME} build #${env.BUILD_NUMBER} was successful!
                    
                    Build URL: ${env.BUILD_URL}
                    Workspace: ${env.WORKSPACE}
                    
                    Deployed Images:
                    - Frontend: ${FRONTEND_IMAGE_NAME}:${IMAGE_TAG}
                    - Caption: ${CAPTION_IMAGE_NAME}:${IMAGE_TAG}
                    - Object Detection: ${OBJECT_IMAGE_NAME}:${IMAGE_TAG}
                    
                    Kubernetes Namespace: ${K8S_NAMESPACE}
                """,
                to: "${EMAIL_RECIPIENTS}"
            )
        }
        failure {
            echo 'Pipeline failed!'
            emailext (
                subject: "Pipeline Failed: ${env.JOB_NAME} [${env.BUILD_NUMBER}]",
                body: """
                    Pipeline ${env.JOB_NAME} build #${env.BUILD_NUMBER} failed!
                    
                    Build URL: ${env.BUILD_URL}
                    Workspace: ${env.WORKSPACE}
                    
                    Please check the Jenkins console output for more details.
                """,
                to: "${EMAIL_RECIPIENTS}"
            )
        }
    }
}